В качестве примера взял шейдер с простым алгоритмом RayMarching на произвольном количестве сфер вместе с источником света.

Возможные способы оптимизации:
1. Использовать swizzle везде где это возможно
```
// Плохо
vec3 nc = p;
nc.x -= s.x;
nc.y -= s.y;
nc.z -= s.z;

// Хорошо
float sphereDist = length(p - s.xyz) - s.w;
```
2. Использовать mad(mad - операция умножения и сложения). Это уменьшает количество тактов для этих действий.
```
// Плохо
vec3 p = rd * dO;
p += ro;

// Хорошо
vec3 p = rd * dO + ro;
```
3. Использовать быстрые встроенные функции
```
// Плохо
vec3 tmp = lightPos - p;
float len = sqrt(tmp.x * tmp.x + tmp.y * tmp.y + tmp.z * tmp.z);
tmp.x /= len;
tmp.y /= len;
tmp.z /= len;

// Хорошо
vec3 l = normalize(lightPos - p);

// Плохо
float dif = clamp(n.x * l.x + n.y * l.y + n.z * l.z, 0., 1.);
// Хорошо
float dif = clamp(dot(n, l), 0., 1.);
```
4. Делать как можно меньше операций во fragment shaders перенося их в vertex shader. Тк FS запускается чаще.
5. Уменьшить точность вычислений.
6. Уменьшить количество вычислений. Если есть что-то что можно посчитать заранее на CPU для всех запусков шейдеров, то это стоит посчитать.
7. Избегать по возможности операторов ветвления(if, for, while).

Тестовые запуски проводились на shadertoy.com